;; Reporters about bus properties.

;; Report the capacity of a bus
to-report get-capacity
  if bus_type = 1 [ report 12 ]
  if bus_type = 2 [ report 60 ]
  if bus_type = 3 [ report 150 ]
end

to-report full?
  report capacity - length bus_passengers = 0
end

; Reports the data that buses communicate to know who's who
to-report bus-spec
  report (list bus_id capacity route_id)
end

; Sorts a list on bus id in decending order. Assumes bus_id is first element of every object in the list
; eg. [ [24 "foo"] [27 "bar"] ] -> [ [27 "foo"] [24 "bar"] ]
to-report sort-by-bus-id [ a_list ]
  report sort-by [ first ?1 > first ?2 ] a_list
end

to-report first-3 [ a_list ]
  report (list (item 0 a_list) (item 1 a_list) (item 2 a_list))
end

;; Report the bus_id of a bus that just got spawned and has the requested_capacity
to-report fresh-bus-with-capacity [ requested_capacity ]
  let belief_on_fleet table:get beliefs "bus-spec"
  let youngest_three first-3 sort-by-bus-id belief_on_fleet

  ; filter on capacity and check if not already assigned
  let candidates filter [ item 1 ? = requested_capacity and item 2 ? = -1 ] youngest_three
  report map [ first ? ] candidates
end

to-report buses-older-than-me
  let start_id 24
  let bus_ids (list)

  while [ start_id < bus_id ] [
    set bus_ids lput start_id bus_ids
    set start_id start_id + 1
  ]

  report bus_ids
end

;;;;; Logic for handling bus-routes
;; Report which route this bus has to take
to-report get-route
  if route_id = 6 [ report [ 3 4 5 10 17 11 ] ]
  if route_id = 5 [ report [ 16 11 1 19 23 14 0 15 18 ] ]
  if route_id = 4 [ report [ 6 8  9 3 16 ] ]
  if route_id = 3 [ report [ 2 8 9 20 21 22 0 ] ]
  if route_id = 2 [ report [ 3 20 12 15 18 ] ]
  if route_id = 1 [ report [ 3 4 10 21 22 13 23 1 7 ] ]
  if route_id = 0 [ report [ 12 22 21 10 13 7 17 5 16 ] ]
end

to-report initial-fleet
  report [ 24 25 26 27 28 29 30 ]
end

;; Report the shortest path a the bus' current stop to another stop
to-report get-shortest-path-to [ bus_stop_id ]
  let route []
  ask bus_stop current_stop[
    set route map [ [who] of ? ] nw:turtles-on-path-to turtle bus_stop_id
  ]
  report route
end

;; Report the next stop on the bus' route
to-report next-stop-on-route [ route_list ]
  ;TODO: breaks when elements occurs multiple times in a list (position always returns the position of the first)
  report item (position current_stop route_list + 1) route_list
end

;; report a list of all postions at witch an element occurs
to-report multiple-position [ element a_list ]
  let result (list)
  let counter 0

  foreach a_list [
    if element = ? [
      set result lput counter result
    ]
    set counter (counter + 1)
  ]

  report result
end
;;;; COMMUNICATION

; Create a message from a message_type (string) and content (any type)
; NB: message_type should equal the name of the reporter in the case of an inform-sync
;
; message_types:
; - inform (send some data, one way)
; - inform-sync (send some data and expect the same data in return)
; - request (ask a turtle to perform some action)
to-report build-message [ message_type content ]
  report list message_type content
end

;; Determines whether to take passenger to next stop; returns boolean
to-report can-take-passenger [ passenger_shortest_path next_bus_stop ]
  report member? next_stop passenger_shortest_path
end
