buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop])
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  passenger_routes ; list containing all ids of the bus passengers and their shortest path ([[passenger_id [shortest path]]  [passenger id [shortest path]]    ...])

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  fixed_route
  route_id
  capacity
  spawn?
  temp_route
  beliefs
  route-style ;  TODO maybe create a new 'fixed route' -> ROUTE 8, which is the flexible style route
]

globals [graph]

to init-buses

  ; Initialize your agents here.
  set spawn? True
  set capacity get-capacity
  set passenger_routes []
  set fixed_route []
  set route_id -1
  init-beliefs
  
  if member? bus_id initial-fleet [ 
    init-initial-fleet
  ]
  
  ; let the whole fleet know you spawned and what route you are taking
  announce-birth

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

; Runs when critical condition is reached. Asks for new bus on the specified route
to request-bus-on-route [ new_route_id new_bus_capacity ]
  let available_bus_ids fresh-bus-with-capacity new_bus_capacity
  if length available_bus_ids > 0 [
    let bus_to_aks first available_bus_ids
    
    ; send request message to one of the waiting buses
    let request_body (list (word "assign-to-route " new_route_id))
    let request_msg build-message "request" request_body
    send-message bus_to_aks request_msg
  ]
end


; Runs when a new flexible bus is requested
; This is done by bus 24 when the ratio total passengers waiting / capacity of fleet > 1
to request-flexible-bus [ new_bus_capacity ]
  ;TODO
end






; Exeption to general initialization, only do this for the first 7 vehicles
to init-initial-fleet
  set route_id (bus_id mod 7)
  set fixed_route get-route
  set temp_route get-shortest-path-to (first fixed_route)  ;to get to the beginning of a route when just spawned
end

; Initialize a table (dictionary) to store beliefs
to init-beliefs
  set beliefs table:make
  
  table:put beliefs "bus-spec" []
end

; drop off passengers at their destination
to drop-off-passengers
  foreach passenger_routes [
    let passenger_id first ?
    let destination last last ?

    ; get shortest path for passenger
    let route_to_destination last ?

    ; drop passengers at their destination or at a transit station on their desired tavel path
    if destination = current_stop or not can-take-passenger route_to_destination next_stop
      [ drop-off-passenger passenger_id
        set passenger_routes remove ( list passenger_id route_to_destination ) passenger_routes
        ]
  ]
end

; pick up as many passengers as possible at current stop
to pick-up-passengers
  let free_seats capacity - length bus_passengers
  let n_waiting length get-passengers-at-stop current_stop
  let to_pickup min list free_seats n_waiting ; How many passengers can be picked up

  ;only pick up passenger if it's next stop of his shortest path is on your route
  foreach n-of to_pickup get-passengers-at-stop current_stop [

    let passenger ?

    ; get shortest path for passenger
    let destination last passenger
    let route_to_destination get-shortest-path-to destination
    let passenger_id first passenger

    ;If the next stop is in the shortest path of the passenger, take him
    if can-take-passenger route_to_destination next_stop[
      pick-up-passenger passenger_id

      ;update passengers in bus, add their shortest path
      let new_bus_passenger (list passenger_id route_to_destination)
      set passenger_routes lput new_bus_passenger passenger_routes
    ]
  ]


end

;; Flip the route when the last stop is reached for fixed route buses
to turn-around
  ; skip when there is no route to ride
  if length fixed_route < 1 [ stop ]
  
  if current_stop = last fixed_route [
    set fixed_route reverse fixed_route
  ]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  set label (word length bus_passengers " / " capacity)
  
  ; TODO: Find alternative for 'count buses'
  if not (last initial-fleet = bus_id) and count buses < 7 [
    add-bus 1
  ]
  if count buses = 8 and bus_id = 31 [
    add-bus 2
    add-bus 3
  ]

  ; Go trough inbox to ensure up to date mental state
  process-inbox
  
  ; Unassigned busses just read their messages
  if not (route_id > -1) [ stop ]

  ; Do normal behaviour
  if current_stop > -1 [
    ifelse member? current_stop fixed_route [
      set next_stop next-stop-on-route fixed_route
      drop-off-passengers
      pick-up-passengers
    ][
      ; otherwise navigate to route
      set next_stop next-stop-on-route temp_route
    ]
  ]


  ; bus 24 checks if new flexible buses are needed everey 3 ticks
  
  if bus_id = 24 [
    if ticks mod 3 = 0[
      
      ; If the 
      if waiting-capacity-ratio > 1.5[
        ;New flexible bus is needed
        
        show "new flex bus is needed"
        
        
      ]
      
      
      
    ]
  ]

  ; add new bus if necessary
   if full? and spawn? [
    request-bus-on-route route_id 12
    set spawn? false
   ]

  ; go towards the next stop
  travel-to next_stop

  ; if bus reaches last stop, turn around (TODO: if-statement outside of procedure?)
  turn-around
end

;;;; COMMUNICATION

; message = [ ticks sender [ performative content ] ]
to process-inbox
  while [not empty? inbox] [
    let message first inbox
    let time item 0 message
    let sender item 1 message
    let body item 2 message
    let performative first body
    let content last body

    if performative = "inform-sync" [
      add-belief-from-msg content
      
      ; first content is a string containing belief_name. 
      ; runresult calls the reporter that is contained by the string 
      ; (eg. runretrieval "bus-spec", calls to-report bus-spec)
      let reciprocal_data runresult (first content)
      let reply_message build-message "inform" (list (first content) reciprocal_data)
      send-message sender reply_message
    ]
    if performative = "inform" [
      add-belief-from-msg content
    ]
    if performative = "request" [
      let action first content
   
      ifelse can-perform action [ 
        agree-to-request sender
        run action
      ][
        fail-on-request sender "Not able to perform this action"
      ]
    ]

    set inbox remove message inbox
  ]
end
  
to agree-to-request [ requester_id ]
  let content build-message "agree" [True]
  send-message requester_id content
end

to fail-on-request [ requester_id reason ]
  let content build-message "failure" reason
  show content
  send-message requester_id content
end


;;;;;;; FLEXIBLE BUS


















;;;;;;; VOTING
;Majority vote to decide next busstop
to vote_next_stop
  
  ;Drop all passengers 
  foreach passenger_routes [
    let passenger_id first ?
    let passenger_destination last last ?
    
    
    ; get shortest path for passenger
    let route_to_destination last ?

    ; remove passengers from both passenger lists
    drop-off-passenger passenger_id
    set passenger_routes remove ( list passenger_id route_to_destination ) passenger_routes
    
  ]
  
  
  let waiting_passengers get-passengers-at-stop current_stop
  
  ; Let all people at current stop vote for next stop
  let votes []
  ; calculate shortest path for all passengers
  foreach waiting_passengers[
    
    let passenger ?

    ; get shortest path for passenger
    let passenger_destination last passenger
    let route_to_destination get-shortest-path-to passenger_destination
    let passenger_id first passenger
    
    ; each passenger votes for it's best next destination
    let vote first route_to_destination
    set votes lput vote votes
  ]
  
  ; Next stop is stop with the most votes (majority vote)
  let next_bus_destination modes votes
  
  ; if a tie occurred go to closest of the bus-stops that tied
  if length next_bus_destination > 1 [
    
    ; closest destination is a tuple of bus-stop distance
    let closest_destination [-1 9999999]
    
    ; Set closest destination to the bus stop that is closest of the most popular 
    foreach next_bus_destination[
      let temp_destination ?
      let temp_distance get-distance current_stop temp_destination
      

      if temp_distance < last closest_destination[
        set closest_destination list temp_distance temp_destination
      ]
    ]
    ; set next destination to closest destination
    set next_bus_destination first closest_destination
    
  ]
  
  ; If no passengers at stop left (all passengers arrived at destination)
  ; Choose next stop randomly from adjacent bus stops
  if length next_bus_destination = 0[
    ;TODO
  ]
  
  ; Set next stop to next_bus_destination
  set next_stop next_bus_destination
  
  ; (ONLY) pick up passengers that voted for that stop 
  pick-up-passengers
    
end




;;;;;;; ASSIGN-TO-ROUTE
;;procedure and reporter belong together
;
; Assign yourself to the new_route_id and let everyone know you did so
to assign-to-route [ new_route_id ]
  if can-assign-to-route new_route_id [
    set route_id new_route_id
    set fixed_route get-route
    set temp_route get-shortest-path-to (first fixed_route)
    add-bus bus_type
    broadcast-reassignment
  ]
end
; check condition on which bus is able to assign itself to a new route
; (currently just if it is not assigned yet)
to-report can-assign-to-route [ new_route_id ]
  report route_id = -1
end
;;;; END

; Take massage content and use it to update belief
; content = [ belief_name belief_content ]
to add-belief-from-msg [ content ]
  let belief build-belief (first content) (last content)
  add-belief belief
end

; Broadcast bus specifications to all busses that were created before the caller
; See to-report bus-spec for the data that is shared
to announce-birth
  foreach buses-older-than-me [
    let msg_content (list "bus-spec" bus-spec)
    let message build-message "inform-sync" msg_content
    send-message ? message
  ]
end

;; Difference with announce-birth is that this message doens't ask for a message back
to broadcast-reassignment
  foreach buses-older-than-me [
    let msg_content (list "bus-spec" bus-spec)
    let message build-message "inform" msg_content
    send-message ? message
  ]
end

;; Add belief to the belief base (avoiding duplicates)
to add-belief [ new_belief ]
  let belief_name first new_belief
  let value last new_belief
  let current_state table:get beliefs belief_name
  
  if belief_name = "bus-spec" [
    let b_id first value
    set current_state filter [ first ? != b_id ] current_state
  ]
  
  if not member? value current_state [
    table:put beliefs belief_name lput value current_state
  ]
end

;;;; BDI

;; Create a belief object of a belief_name (string) and content (any object)
to-report build-belief [ belief_name content ]
  report list belief_name content
end

to-report beliefs-with-name [ belief_name ]
  let belief_set filter [ first ? = belief_name ] beliefs
  let values (list)

  ; Add the content of each belief in the belief_set to a new list
  foreach belief_set [
    set values lput last ? values
  ]

  report values
end
