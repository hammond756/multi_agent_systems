buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".

  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop])
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  bus_passengers2 ; list containing all ids of the bus passengers and their shortest path ([[passenger_id [shortest path]]  [passenger id [shortest path]]    ...])

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  fixed_route
  route_id
  capacity
  spawn?
  temp_route
  beliefs
]

globals [graph]

to init-buses

  ; Initialize your agents here.
  set spawn? True
  set route_id (bus_id mod 7)
  set fixed_route get-route
  set capacity get-capacity
  set beliefs []
  set temp_route get-shortest-path-to (first fixed_route)  ;to get to the beginning of a route when just spawned
  go-to-route

  if bus_id <= 31 [ add-new-bus 1 ]

  ; let the whole fleet know you spawned and what route you are taking
  announce-birth

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

; drop off passengers at their destination
to drop-off-passengers
  foreach bus_passengers2 [
    let passenger_id first ?
    let destination last last ?

    ; get shortest path for passenger
    let route_to_destination last ?

    if destination = current_stop or not can-take-passenger route_to_destination next_stop
      [ drop-off-passenger passenger_id
        set bus_passengers2 remove ( list passenger_id route_to_destination ) bus_passengers2
        ]
  ]
end

; pick up as many passengers as possible at current stop
to pick-up-passengers
  let free_seats capacity - length bus_passengers
  let n_waiting length get-passengers-at-stop current_stop
  let to_pickup min list free_seats n_waiting ; How many passengers can be picked up

  ;TODO only pick up passenger if it's next stop of his shortest path is on your route
  foreach n-of to_pickup get-passengers-at-stop current_stop [

    let passenger ?

    ; get shortest path for passenger
    let destination last passenger
    let route_to_destination get-shortest-path-to destination
    let passenger_id first passenger

    ;If the next stop is in the shortest path of the passenger, take him
    if can-take-passenger route_to_destination next_stop[
      pick-up-passenger passenger_id

      ;update passengers in bus, add their shortest path
      let new_bus_passenger []
      set new_bus_passenger fput passenger_id new_bus_passenger
      set new_bus_passenger lput route_to_destination new_bus_passenger
      set bus_passengers2 lput new_bus_passenger bus_passengers

    ]
  ]


end

to add-new-bus [ bus_size ]
    if capacity - length bus_passengers = 0 and spawn? [
    add-bus bus_size

    ; just allow a bus to spawn once
    set spawn? False
  ]
end

to turn-around
  if current_stop = last fixed_route [
    set fixed_route reverse fixed_route
  ]
end

to go-to-route
  ; function that brings the bus to its fixed route after it spawns

  if not member? current_stop fixed_route [
    foreach temp_route [travel-to ?]
  ]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  set label (word length bus_passengers " / " capacity)

  ; Go trough inbox to ensure up to date mental state
  process-inbox

  ; if the bus is currently at a stop
  if current_stop > -1 [
    set next_stop next-stop-on-route
    drop-off-passengers
    pick-up-passengers
  ]

  ; add new bus if necessary
  add-new-bus 3

  ; go towards the next stop
  travel-to next_stop

  ; if bus reaches last stop, turn around (TODO: if-statement outside of procedure?)
  turn-around
end

;;;; COMMUNICATION

; message = [ ticks sender [ performative content ] ]
to process-inbox
  while [not empty? inbox] [
    let message first inbox
    let time item 0 message
    let sender item 1 message
    let body item 2 message
    let performative first body
    let content last body

    if performative = "inform" [
      let belief build-belief (first content) (last content)
      add-belief belief
    ]

    set inbox remove message inbox
  ]
end

to announce-birth
  foreach buses-older-than-me [
    let msg_belief (list "bus" (list bus_id route_id))
    let message build-message "inform" msg_belief
    send-message ? message
  ]
end

;; Add belief to the belief base (avoiding duplicates)
to add-belief [ new_belief ]
  if not member? new_belief beliefs [
    set beliefs fput new_belief beliefs
  ]
end

;;;; BDI

;; Create a belief object of a belief_name (string) and content (any object)
to-report build-belief [ belief_name content ]
  report list belief_name content
end

to-report beliefs-with-name [ belief_name ]
  let belief_set filter [ first ? = belief_name ] beliefs
  let values (list)

  ; Add the content of each belief in the belief_set to a new list
  foreach belief_set [
    set values lput last ? values
  ]

  report values
end
